import { CustomNode, CustomEdge } from "../types/flowTypes";

export interface GeneratedCode {
  mainScript: string;
  requirements?: string;
  config?: string;
  tests?: string;
  documentation?: string;
}

export interface CodeGeneratorConfig {
  language: 'python' | 'javascript' | 'json' | 'yaml';
  includeTests?: boolean;
  includeDocumentation?: boolean;
}

/**
 * Multi-Language Code Generator
 */
export class CodeGenerator {
  generateExecutableCode(
    workflow: { nodes: CustomNode[]; edges: CustomEdge[] },
    config: CodeGeneratorConfig
  ): GeneratedCode {
    switch (config.language) {
      case 'python':
        return this.generatePythonCode(workflow, config);
      case 'javascript':
        return this.generateJavaScriptCode(workflow, config);
      case 'json':
        return this.generateJSONConfig(workflow, config);
      case 'yaml':
        return this.generateYAMLConfig(workflow, config);
      default:
        throw new Error(`Unsupported language: ${config.language}`);
    }
  }

  private generatePythonCode(workflow: { nodes: CustomNode[]; edges: CustomEdge[] }, generatorConfig: CodeGeneratorConfig): GeneratedCode {
    const { nodes, edges } = workflow;

    const mainScript = `#!/usr/bin/env python3
"""
Generated Workflow Implementation
Generated by AI Workflow Generator
"""

import asyncio
import logging
import json
from datetime import datetime
from dataclasses import dataclass
from typing import Dict, Any

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class WorkflowContext:
    data: Dict[str, Any]
    metadata: Dict[str, Any]
    start_time: datetime

class WorkflowEngine:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.nodes = {}
        self.edges = {}
        self.setup_workflow()
    
    def setup_workflow(self):
        """Setup workflow nodes and edges"""
        # Define nodes
        self.nodes = {
${nodes.map(node => `            "${node.id}": {
                "id": "${node.id}",
                "label": "${node.data?.label || node.id}",
                "type": "${node.type || 'process'}"
            }`).join(',\n')}
        }
        
        # Define edges
        self.edges = {
${edges.map(edge => `            "${edge.id}": {
                "source": "${edge.source}",
                "target": "${edge.target}",
                "label": "${edge.label || ''}"
            }`).join(',\n')}
        }
    
    async def execute(self, initial_data: Dict[str, Any]) -> WorkflowContext:
        """Execute the workflow"""
        context = WorkflowContext(
            data=initial_data,
            metadata={},
            start_time=datetime.now()
        )
        
        self.logger.info(f"Starting workflow with {len(self.nodes)} nodes")
        
        try:
            # Find start nodes (nodes with no incoming edges)
            start_nodes = [node_id for node_id in self.nodes.keys() 
                          if not any(edge["target"] == node_id for edge in self.edges.values())]
            
            if not start_nodes:
                self.logger.warning("No start nodes found")
                return context
            
            # Execute from start nodes
            for start_node in start_nodes:
                await self.execute_node(start_node, context)
            
            self.logger.info("Workflow completed successfully")
            return context
            
        except Exception as e:
            self.logger.error(f"Workflow failed: {e}")
            raise
    
    async def execute_node(self, node_id: str, context: WorkflowContext):
        """Execute a single node"""
        node = self.nodes.get(node_id)
        if not node:
            raise ValueError(f"Node {node_id} not found")
        
        self.logger.info(f"Executing {node['label']} ({node['type']})")
        
        try:
            # Node-specific logic
            if node['type'] == 'process':
                context.data[f"{node_id}_processed"] = True
                context.data[f"{node_id}_timestamp"] = datetime.now().isoformat()
            elif node['type'] == 'decision':
                context.data[f"{node_id}_decision"] = "continue"
            elif node['type'] == 'terminal':
                context.data[f"{node_id}_completed"] = True
            
            # Update metadata
            context.metadata[f"{node_id}_executed"] = True
            context.metadata[f"{node_id}_execution_time"] = datetime.now().isoformat()
            
            # Find next nodes
            next_nodes = [edge["target"] for edge in self.edges.values() 
                         if edge["source"] == node_id]
            
            # Execute next nodes
            for next_node in next_nodes:
                await self.execute_node(next_node, context)
                
        except Exception as e:
            self.logger.error(f"Error in node {node_id}: {e}")
            raise

async def main():
    """Main entry point"""
    engine = WorkflowEngine()
    
    initial_data = {
        "input": "example_input",
        "timestamp": datetime.now().isoformat()
    }
    
    try:
        result = await engine.execute(initial_data)
        print(f"Workflow completed. Final data: {result.data}")
    except Exception as e:
        print(f"Workflow failed: {e}")

if __name__ == "__main__":
    asyncio.run(main())
`;

    const requirements = `asyncio
logging
dataclasses
typing
datetime`;

    const configJson = JSON.stringify({
      workflow: {
        name: "Generated Workflow",
        version: "1.0.0",
        nodes: nodes.map(n => ({
          id: n.id,
          label: n.data?.label,
          type: n.type
        })),
        edges: edges.map(e => ({
          source: e.source,
          target: e.target,
          label: e.label
        }))
      }
    }, null, 2);

    return {
      mainScript,
      requirements,
      config: configJson,
      tests: generatorConfig.includeTests ? this.generatePythonTests(nodes, edges) : undefined,
      documentation: generatorConfig.includeDocumentation ? this.generatePythonDocs(nodes, edges) : undefined
    };
  }

  private generateJavaScriptCode(workflow: { nodes: CustomNode[]; edges: CustomEdge[] }, generatorConfig: CodeGeneratorConfig): GeneratedCode {
    const { nodes, edges } = workflow;

    const mainScript = `/**
 * Generated Workflow Implementation
 * Generated by AI Workflow Generator
 */

const fs = require('fs').promises;

class WorkflowContext {
    constructor(initialData = {}) {
        this.data = initialData;
        this.metadata = {};
        this.startTime = new Date();
    }
}

class WorkflowEngine {
    constructor() {
        this.nodes = new Map();
        this.edges = new Map();
        this.setupWorkflow();
    }

    setupWorkflow() {
        // Define nodes
${nodes.map(node => `        this.nodes.set('${node.id}', {
            id: '${node.id}',
            label: '${node.data?.label || node.id}',
            type: '${node.type || 'process'}'
        });`).join('\n')}
        
        // Define edges
${edges.map(edge => `        this.edges.set('${edge.id}', {
            source: '${edge.source}',
            target: '${edge.target}',
            label: '${edge.label || ''}'
        });`).join('\n')}
    }

    async execute(initialData = {}) {
        const context = new WorkflowContext(initialData);
        console.log(\`Starting workflow with \${this.nodes.size} nodes\`);

        try {
            // Find start nodes
            const startNodes = Array.from(this.nodes.keys()).filter(nodeId => 
                !Array.from(this.edges.values()).some(edge => edge.target === nodeId)
            );

            if (startNodes.length === 0) {
                console.warn('No start nodes found');
                return context;
            }

            // Execute from start nodes
            for (const startNode of startNodes) {
                await this.executeNode(startNode, context);
            }

            console.log('Workflow completed successfully');
            return context;

        } catch (error) {
            console.error('Workflow failed:', error);
            throw error;
        }
    }

    async executeNode(nodeId, context) {
        const node = this.nodes.get(nodeId);
        if (!node) {
            throw new Error(\`Node \${nodeId} not found\`);
        }

        console.log(\`Executing \${node.label} (\${node.type})\`);

        try {
            // Node-specific logic
            if (node.type === 'process') {
                context.data[\`\${nodeId}_processed\`] = true;
                context.data[\`\${nodeId}_timestamp\`] = new Date().toISOString();
            } else if (node.type === 'decision') {
                context.data[\`\${nodeId}_decision\`] = 'continue';
            } else if (node.type === 'terminal') {
                context.data[\`\${nodeId}_completed\`] = true;
            }

            // Update metadata
            context.metadata[\`\${nodeId}_executed\`] = true;
            context.metadata[\`\${nodeId}_execution_time\`] = new Date().toISOString();

            // Find next nodes
            const nextNodes = Array.from(this.edges.values())
                .filter(edge => edge.source === nodeId)
                .map(edge => edge.target);

            // Execute next nodes
            for (const nextNode of nextNodes) {
                await this.executeNode(nextNode, context);
            }

        } catch (error) {
            console.error(\`Error in node \${nodeId}:\`, error);
            throw error;
        }
    }
}

async function main() {
    const engine = new WorkflowEngine();
    
    const initialData = {
        input: 'example_input',
        timestamp: new Date().toISOString()
    };

    try {
        const result = await engine.execute(initialData);
        console.log('Workflow completed. Final data:', result.data);
    } catch (error) {
        console.error('Workflow failed:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = { WorkflowEngine, WorkflowContext };
`;

    const configJson = JSON.stringify({
      workflow: {
        name: "Generated Workflow",
        version: "1.0.0",
        nodes: nodes.map(n => ({
          id: n.id,
          label: n.data?.label,
          type: n.type
        })),
        edges: edges.map(e => ({
          source: e.source,
          target: e.target,
          label: e.label
        }))
      }
    }, null, 2);

    return {
      mainScript,
      config: configJson,
      tests: generatorConfig.includeTests ? this.generateJavaScriptTests(nodes, edges) : undefined,
      documentation: generatorConfig.includeDocumentation ? this.generateJavaScriptDocs(nodes, edges) : undefined
    };
  }

  private generateJSONConfig(workflow: { nodes: CustomNode[]; edges: CustomEdge[] }, generatorConfig: CodeGeneratorConfig): GeneratedCode {
    const { nodes, edges } = workflow;

    const mainScript = JSON.stringify({
      workflow: {
        name: "Generated Workflow",
        version: "1.0.0",
        description: "Automatically generated workflow configuration",
        nodes: nodes.map(n => ({
          id: n.id,
          label: n.data?.label || n.id,
          type: n.type || 'process',
          description: n.data?.description || 'No description provided'
        })),
        edges: edges.map(e => ({
          id: e.id,
          source: e.source,
          target: e.target,
          label: e.label || ''
        })),
        settings: {
          timeout: 300,
          retry_attempts: 3,
          log_level: "INFO"
        }
      }
    }, null, 2);

    return {
      mainScript,
      documentation: generatorConfig.includeDocumentation ? this.generateJSONDocs(nodes, edges) : undefined
    };
  }

  private generateYAMLConfig(workflow: { nodes: CustomNode[]; edges: CustomEdge[] }, generatorConfig: CodeGeneratorConfig): GeneratedCode {
    const { nodes, edges } = workflow;

    const mainScript = `# Generated Workflow Configuration
# Generated by AI Workflow Generator

workflow:
  name: "Generated Workflow"
  version: "1.0.0"
  description: "Automatically generated workflow configuration"
  
  nodes:
${nodes.map(node => `    - id: "${node.id}"
      label: "${node.data?.label || node.id}"
      type: "${node.type || 'process'}"
      description: "${node.data?.description || 'No description provided'}"`).join('\n')}
  
  edges:
${edges.map(edge => `    - id: "${edge.id}"
      source: "${edge.source}"
      target: "${edge.target}"
      label: "${edge.label || ''}"`).join('\n')}
  
  settings:
    timeout: 300
    retry_attempts: 3
    log_level: "INFO"`;

    return {
      mainScript,
      documentation: generatorConfig.includeDocumentation ? this.generateYAMLDocs(nodes, edges) : undefined
    };
  }

  private generatePythonTests(nodes: CustomNode[], edges: CustomEdge[]): string {
    return `import pytest
import asyncio
from unittest.mock import Mock

class TestWorkflow:
    @pytest.fixture
    def workflow_engine(self):
        from main import WorkflowEngine
        return WorkflowEngine()
    
    @pytest.mark.asyncio
    async def test_workflow_execution(self, workflow_engine):
        """Test complete workflow execution"""
        initial_data = {"test": "data"}
        result = await workflow_engine.execute(initial_data)
        assert result is not None
        assert hasattr(result, 'data')
    
    @pytest.mark.asyncio
    async def test_node_execution(self, workflow_engine):
        """Test individual node execution"""
        context = Mock()
        context.data = {}
        context.metadata = {}
        
        # Test each node
${nodes.map(node => `        # Test ${node.data?.label || node.id}
        await workflow_engine.execute_node("${node.id}", context)`).join('\n')}

if __name__ == "__main__":
    pytest.main([__file__])`;
  }

  private generateJavaScriptTests(nodes: CustomNode[], edges: CustomEdge[]): string {
    return `const { WorkflowEngine, WorkflowContext } = require('./main');

describe('Generated Workflow', () => {
    let engine;

    beforeEach(() => {
        engine = new WorkflowEngine();
    });

    test('should execute workflow successfully', async () => {
        const initialData = { test: 'data' };
        const result = await engine.execute(initialData);
        expect(result).toBeDefined();
        expect(result.data).toBeDefined();
    });

    test('should handle node execution', async () => {
        const context = new WorkflowContext({ test: 'data' });
${nodes.map(node => `        // Test ${node.data?.label || node.id}
        await engine.executeNode("${node.id}", context);`).join('\n')}
    });
});`;
  }

  private generatePythonDocs(nodes: CustomNode[], edges: CustomEdge[]): string {
    return `# Generated Workflow Documentation

## Overview
This workflow was automatically generated by the AI Workflow Generator.

## Workflow Structure

### Nodes
${nodes.map(node => `- **${node.data?.label || node.id}** (${node.type || 'process'}): ${node.data?.description || 'No description provided'}`).join('\n')}

### Connections
${edges.map(edge => {
  const sourceNode = nodes.find(n => n.id === edge.source);
  const targetNode = nodes.find(n => n.id === edge.target);
  return `- ${sourceNode?.data?.label || edge.source} → ${targetNode?.data?.label || edge.target}${edge.label ? ` (${edge.label})` : ''}`;
}).join('\n')}

## Usage

### Prerequisites
\`\`\`bash
pip install -r requirements.txt
\`\`\`

### Running the Workflow
\`\`\`bash
python main.py
\`\`\`

### Configuration
Edit the \`config.json\` file to modify workflow settings.

## Architecture

The workflow is implemented using an asynchronous execution engine with the following components:

- **WorkflowEngine**: Main execution engine
- **WorkflowContext**: Execution context and data container
- **Node Handlers**: Individual node implementations

## Testing

Run the test suite:
\`\`\`bash
pytest tests/
\`\`\`

## Customization

To customize the workflow:

1. Modify the node handler methods in \`main.py\`
2. Update the configuration in \`config.json\`
3. Add new dependencies to \`requirements.txt\`

## Support

For issues or questions, refer to the generated code comments or contact the development team.`;
  }

  private generateJavaScriptDocs(nodes: CustomNode[], edges: CustomEdge[]): string {
    return `# Generated Workflow Documentation

## Overview
This workflow was automatically generated by the AI Workflow Generator.

## Workflow Structure

### Nodes
${nodes.map(node => `- **${node.data?.label || node.id}** (${node.type || 'process'}): ${node.data?.description || 'No description provided'}`).join('\n')}

### Connections
${edges.map(edge => {
  const sourceNode = nodes.find(n => n.id === edge.source);
  const targetNode = nodes.find(n => n.id === edge.target);
  return `- ${sourceNode?.data?.label || edge.source} → ${targetNode?.data?.label || edge.target}${edge.label ? ` (${edge.label})` : ''}`;
}).join('\n')}

## Usage

### Running the Workflow
\`\`\`bash
node main.js
\`\`\`

### Configuration
Edit the \`config.json\` file to modify workflow settings.

## Architecture

The workflow is implemented using an asynchronous execution engine with the following components:

- **WorkflowEngine**: Main execution engine
- **WorkflowContext**: Execution context and data container
- **Node Handlers**: Individual node implementations

## Testing

Run the test suite:
\`\`\`bash
npm test
\`\`\`

## Customization

To customize the workflow:

1. Modify the node handler methods in \`main.js\`
2. Update the configuration in \`config.json\`
3. Add new dependencies to \`package.json\`

## Support

For issues or questions, refer to the generated code comments or contact the development team.`;
  }

  private generateJSONDocs(nodes: CustomNode[], edges: CustomEdge[]): string {
    return `# JSON Configuration Documentation

## Overview
This JSON configuration file defines the workflow structure and settings.

## Usage

Load this configuration in your application:

\`\`\`javascript
const fs = require('fs');
const config = JSON.parse(fs.readFileSync('workflow.json', 'utf8'));
\`\`\`

\`\`\`python
import json

with open('workflow.json', 'r') as file:
    config = json.load(file)
\`\`\`

## Customization

Modify the JSON file to customize workflow behavior and settings.`;
  }

  private generateYAMLDocs(nodes: CustomNode[], edges: CustomEdge[]): string {
    return `# YAML Configuration Documentation

## Overview
This YAML configuration file defines the workflow structure and settings.

## Usage

Load this configuration in your application:

\`\`\`python
import yaml

with open('workflow.yaml', 'r') as file:
    config = yaml.safe_load(file)
\`\`\`

## Customization

Modify the YAML file to customize workflow behavior and settings.`;
  }
}

// Export singleton instance
export const codeGenerator = new CodeGenerator();
